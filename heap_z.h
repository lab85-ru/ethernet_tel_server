//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

#ifndef __HEAP_Z_H
#define __HEAP_Z_H

#pragma pack( push, 1 )
//----------------------------------------------------------------------------
typedef union type_size {
	unsigned long mark;
	struct {
	unsigned long size:24;
	unsigned long type:8;
	};
}type_size;

// Memory Control Block (MCB)
//----------------------------------------------------------------------------
typedef struct heap_mcb
{
	struct heap_mcb *next;   	// ”казатель на следующий MCB
			  					// mcb.next  последнего MCM всегда указывает на
			  					// первый MCB.
	struct heap_mcb *prev;   	// ”казатель на предыдущий MCB.
								// ƒл€ первого MCB этот указатель указывает
								// сам на себ€.
	union type_size ts;  		// –азмер блока пам€ти (в байтах)

	void *owner;        		// ¬ладелец блока пам€ти (TCB владельца)
								// —обственно контролируемый блок пам€ти расположен сразу за MCB
} heap_mcb;


//----------------------------------------------------------------------------
// —труктура-описатель кучи (тип-структура t_heap)
//----------------------------------------------------------------------------
typedef struct heap_t
{ 	// ”казатель на начало heap (первый MCB)
	struct heap_mcb *start;
	// ”казатель на первый свободный MCB
	struct heap_mcb *freem;
	// RAW размер кучи
	unsigned long hsize;
} heap_t;
#pragma pack( pop )

//----------------------------------------------------------------------------
// —труктура описывающа€ heap во встроенном RAM контроллера
extern heap_t system_heap;

// »нициализаци€ heap (используетс€ дл€ системы) во встроенном RAM контроллера
void init_system_heap( void );//int add_ram );

// »нициализаци€ произвольной пам€ти в качестве heap
void heapinit( heap_t *heap );

// –езервирует пам€ть в куче 'heap', размером 'size' байт.
// ¬озвращает указатель на зарезервированную пам€ть
// ≈сли в куче не достаточно пам€ти, то возвращает NULL
void *malloc_z( heap_t *heap, size_t size, int type, void *owner );

//----------------------------------------------------------------------------
// ќсвобождает зарезервированную пам€ть, на которую указывает 'ptr' в 'heap'.
// ≈сли указатель указывает на пам€ть, котора€ не была выделена ранее
// malloc_z() или указатель 'ptr' равен 0, то ничего не происходит,
// но не исклчен вылет на exception :(
void free_z( heap_t *heap, void *ptr );


//----------------------------------------------------------------------------
enum MCB_MARK {
	MARK_FREE = 0,
	MARK_SYSTEM,
	MARK_TCB,
	MARK_STACK,
	MARK_QCB,
	MARK_QUEUE,
	MARK_CCB,
	MARK_MUTEX,
	MARK_8,
	MARK_9,
	MARK_A,
	MARK_B,
	MARK_C,
	MARK_D,
	MARK_E,
	MARK_F
};

//----------------------------------------------------------------------------
// —писок блоков пам€ти
//----------------------------------------------------------------------------
void heaplist_z( heap_t *heap );

#endif /* __HEAP_Z_H */
